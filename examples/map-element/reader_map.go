// +build !ignore_autogenerated

// Code generated by collections-gen. DO NOT EDIT.

package mapelement

import (
	"io"
	"reflect"
	"sort"
)

// MapStringToReaderCollection is a collection of map[string]io.Reader values.
type MapStringToReaderCollection struct {
	items []map[string]io.Reader
}

// NewMapStringToReaderCollection creates a new collection from a slice of map[string]io.Reader.
func NewMapStringToReaderCollection(items []map[string]io.Reader) *MapStringToReaderCollection {
	return &MapStringToReaderCollection{items}
}

// Interface returns the underlying slice used by the collection as interface{}
// value.
func (c *MapStringToReaderCollection) Interface() interface{} {
	return c.items
}

// Items returns the underlying slice of map[string]io.Reader values used by the
// collection.
func (c *MapStringToReaderCollection) Items() []map[string]io.Reader {
	return c.items
}

// EachIndex calls fn for every item in the collection. The slice index of the
// item is passed to fn as the second argument.
func (c *MapStringToReaderCollection) EachIndex(fn func(map[string]io.Reader, int)) {
	for i, item := range c.items {
		fn(item, i)
	}
}

// Each calls fn for every item in the collection.
func (c *MapStringToReaderCollection) Each(fn func(map[string]io.Reader)) {
	c.EachIndex(func(item map[string]io.Reader, _ int) {
		fn(item)
	})
}

// IndexOf searches for el in the collection and returns the first index where
// el is found. If el is not present in the collection IndexOf will return -1.
func (c *MapStringToReaderCollection) IndexOf(el map[string]io.Reader) int {
	for i, item := range c.items {
		if reflect.DeepEqual(item, el) {
			return i
		}
	}

	return -1
}

// First returns the first item from the collection. Will panic if the
// underlying slice is empty.
func (c *MapStringToReaderCollection) First() map[string]io.Reader {
	return c.Nth(0)
}

// FirstN returns the first n map[string]io.Reader items of the collection. Will
// return less than n items if the underlying slice's length is < n.
func (c *MapStringToReaderCollection) FirstN(n int) []map[string]io.Reader {
	if n > c.Len() {
		return c.Items()
	}

	return c.Slice(0, n)
}

// Last returns the last item from the collection. Will panic if the underlying
// slice is empty.
func (c *MapStringToReaderCollection) Last() map[string]io.Reader {
	return c.Nth(c.Len() - 1)
}

// LastN returns the last n map[string]io.Reader items of the collection. Will return
// less than n items if the underlying slice's length is < n.
func (c *MapStringToReaderCollection) LastN(n int) []map[string]io.Reader {
	if c.Len()-n < 0 {
		return c.Items()
	}

	return c.Slice(c.Len()-n, c.Len())
}

// Get returns the item at pos from the collection. Will panic if the
// underlying slice is shorter than pos+1.
func (c *MapStringToReaderCollection) Get(pos int) map[string]io.Reader {
	return c.Nth(pos)
}

// Nth returns the nth item from the collection. Will panic if the underlying
// slice is shorter than pos+1.
func (c *MapStringToReaderCollection) Nth(pos int) map[string]io.Reader {
	return c.items[pos]
}

// Len returns the length of the underlying map[string]io.Reader slice.
func (c *MapStringToReaderCollection) Len() int {
	return len(c.items)
}

// Cap returns the capacity of the underlying map[string]io.Reader slice.
func (c *MapStringToReaderCollection) Cap() int {
	return cap(c.items)
}

// Append appends items and returns the collection.
func (c *MapStringToReaderCollection) Append(items ...map[string]io.Reader) *MapStringToReaderCollection {
	c.items = append(c.items, items...)
	return c
}

// Prepend prepends items and returns the collection.
func (c *MapStringToReaderCollection) Prepend(items ...map[string]io.Reader) *MapStringToReaderCollection {
	c.items = append(items, c.items...)
	return c
}

// Copy creates a copy of the collection and the underlying map[string]io.Reader slice.
func (c *MapStringToReaderCollection) Copy() *MapStringToReaderCollection {
	s := make([]map[string]io.Reader, c.Len(), c.Len())
	copy(s, c.items)

	return NewMapStringToReaderCollection(s)
}

// Filter removes all items from the collection for which fn evaluates to
// false and returns c.
func (c *MapStringToReaderCollection) Filter(fn func(map[string]io.Reader) bool) *MapStringToReaderCollection {
	s := c.items[:0]

	for _, item := range c.items {
		if fn(item) {
			s = append(s, item)
		}
	}

	var zeroValue map[string]io.Reader

	for i := len(s); i < len(c.items); i++ {
		c.items[i] = zeroValue
	}

	c.items = s

	return c
}

// Collect removes all items from the collection for which fn evaluates to
// false and returns c.
func (c *MapStringToReaderCollection) Collect(fn func(map[string]io.Reader) bool) *MapStringToReaderCollection {
	return c.Filter(fn)
}

// Reject removes all items from the collection for which fn evaluates to
// true and returns c.
func (c *MapStringToReaderCollection) Reject(fn func(map[string]io.Reader) bool) *MapStringToReaderCollection {
	return c.Filter(func(v map[string]io.Reader) bool {
		return !fn(v)
	})
}

// Partition partitions the collection into two new collections. The first
// collection contains all items where fn evaluates to true, the second one all
// items where fn evaluates to false.
func (c *MapStringToReaderCollection) Partition(fn func(map[string]io.Reader) bool) (*MapStringToReaderCollection, *MapStringToReaderCollection) {
	lhs := make([]map[string]io.Reader, 0, c.Len())
	rhs := make([]map[string]io.Reader, 0, c.Len())

	for _, item := range c.items {
		if fn(item) {
			lhs = append(lhs, item)
		} else {
			rhs = append(rhs, item)
		}
	}

	return NewMapStringToReaderCollection(lhs), NewMapStringToReaderCollection(rhs)
}

// Map calls fn for each item in the collection an replaces its value with the
// result of fn.
func (c *MapStringToReaderCollection) Map(fn func(map[string]io.Reader) map[string]io.Reader) *MapStringToReaderCollection {
	return c.MapIndex(func(item map[string]io.Reader, _ int) map[string]io.Reader {
		return fn(item)
	})
}

// MapIndex calls fn for each item in the collection an replaces its value with the
// result of fn.
func (c *MapStringToReaderCollection) MapIndex(fn func(map[string]io.Reader, int) map[string]io.Reader) *MapStringToReaderCollection {
	for i, item := range c.items {
		c.items[i] = fn(item, i)

	}

	return c
}

// Reduce calls fn for each item in c and reduces the result into reducer. The
// reducer contains the value returned by the call to fn for the previous item.
// Reducer will be the zero map[string]io.Reader value on the first invocation.
func (c *MapStringToReaderCollection) Reduce(fn func(reducer map[string]io.Reader, item map[string]io.Reader) map[string]io.Reader) map[string]io.Reader {
	var reducer map[string]io.Reader

	for _, item := range c.items {
		reducer = fn(reducer, item)
	}

	return reducer
}

// Find returns the first item for which fn evaluates to true. If the
// collection does not contain a matching item, Find will return the zero
// map[string]io.Reader value. If you need to distinguish zero values from a condition
// that did not match any item consider using FindOk instead.
func (c *MapStringToReaderCollection) Find(fn func(map[string]io.Reader) bool) map[string]io.Reader {
	item, _ := c.FindOk(fn)

	return item
}

// FindOk returns the first item for which fn evaluates to true. If the
// collection does not contain a matching item, FindOk will return the zero
// map[string]io.Reader value. The second return value denotes whether the condition
// matched any item or not.
func (c *MapStringToReaderCollection) FindOk(fn func(map[string]io.Reader) bool) (map[string]io.Reader, bool) {
	for _, item := range c.items {
		if fn(item) {
			return item, true
		}
	}

	var zeroValue map[string]io.Reader
	return zeroValue, false
}

// Any returns true as soon as fn evaluates to true for one item in c.
func (c *MapStringToReaderCollection) Any(fn func(map[string]io.Reader) bool) bool {
	for _, item := range c.items {
		if fn(item) {
			return true
		}
	}

	return false
}

// All returns true if fn evaluates to true for all items in c.
func (c *MapStringToReaderCollection) All(fn func(map[string]io.Reader) bool) bool {
	for _, item := range c.items {
		if !fn(item) {
			return false
		}
	}

	return true
}

// Contains returns true if the collection contains el.
func (c *MapStringToReaderCollection) Contains(el map[string]io.Reader) bool {
	for _, item := range c.items {
		if reflect.DeepEqual(item, el) {
			return true
		}
	}

	return false
}

// Sort sorts the collection using the passed in comparator func.
func (c *MapStringToReaderCollection) Sort(fn func(map[string]io.Reader, map[string]io.Reader) bool) *MapStringToReaderCollection {
	sort.Slice(c.items, c.lessFunc(fn))
	return c
}

// IsSorted returns true if the collection is sorted in the order defined by
// the passed in comparator func.
func (c *MapStringToReaderCollection) IsSorted(fn func(map[string]io.Reader, map[string]io.Reader) bool) bool {
	return sort.SliceIsSorted(c.items, c.lessFunc(fn))
}

func (c *MapStringToReaderCollection) lessFunc(fn func(map[string]io.Reader, map[string]io.Reader) bool) func(int, int) bool {
	return func(i, j int) bool {
		return fn(c.items[i], c.items[j])
	}
}

// Reverse reverses the order of the collection items in place and returns c.
func (c *MapStringToReaderCollection) Reverse() *MapStringToReaderCollection {
	for l, r := 0, len(c.items)-1; l < r; l, r = l+1, r-1 {
		c.items[l], c.items[r] = c.items[r], c.items[l]
	}

	return c
}

// Remove removes the collection item at position pos. Will panic if pos is out
// of bounds.
func (c *MapStringToReaderCollection) Remove(pos int) *MapStringToReaderCollection {
	c.items = append(c.items[:pos], c.items[pos+1:]...)
	return c
}

// RemoveItem removes all instances of item from the collection and returns it.
func (c *MapStringToReaderCollection) RemoveItem(item map[string]io.Reader) *MapStringToReaderCollection {
	for i, el := range c.items {
		if reflect.DeepEqual(el, item) {
			c.items = append(c.items[:i], c.items[i+1:]...)
		}
	}

	return c
}

// InsertItem inserts item into the collection at position pos. Will panic if
// pos is out of bounds.
func (c *MapStringToReaderCollection) InsertItem(item map[string]io.Reader, pos int) *MapStringToReaderCollection {
	var zeroValue map[string]io.Reader
	c.items = append(c.items, zeroValue)
	copy(c.items[pos+1:], c.items[pos:])
	c.items[pos] = item
	return c
}

// Cut returns a copy of the underlying map[string]io.Reader slice with the items
// between index i and j removed. Will panic if i or j is out of bounds of the
// underlying slice.
func (c *MapStringToReaderCollection) Cut(i, j int) []map[string]io.Reader {
	s := make([]map[string]io.Reader, 0, c.Len())
	s = append(s, c.items[:i]...)
	return append(s, c.items[j:]...)
}

// Slice returns the map[string]io.Reader items between slice index i and j. Will
// panic if i or j is out of bounds.
func (c *MapStringToReaderCollection) Slice(i, j int) []map[string]io.Reader {
	return c.items[i:j]
}

// ImmutableMapStringToReaderCollection is an immutable collection of map[string]io.Reader values.
type ImmutableMapStringToReaderCollection struct {
	items []map[string]io.Reader
}

// NewImmutableMapStringToReaderCollection creates a new immutable collection from a slice of map[string]io.Reader.
func NewImmutableMapStringToReaderCollection(items []map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	return &ImmutableMapStringToReaderCollection{items}
}

// Interface returns the underlying slice used by the collection as interface{}
// value.
func (c *ImmutableMapStringToReaderCollection) Interface() interface{} {
	return c.items
}

// Items returns the underlying slice of map[string]io.Reader values used by the
// collection.
func (c *ImmutableMapStringToReaderCollection) Items() []map[string]io.Reader {
	return c.items
}

// EachIndex calls fn for every item in the collection. The slice index of the
// item is passed to fn as the second argument.
func (c *ImmutableMapStringToReaderCollection) EachIndex(fn func(map[string]io.Reader, int)) {
	for i, item := range c.items {
		fn(item, i)
	}
}

// Each calls fn for every item in the collection.
func (c *ImmutableMapStringToReaderCollection) Each(fn func(map[string]io.Reader)) {
	c.EachIndex(func(item map[string]io.Reader, _ int) {
		fn(item)
	})
}

// IndexOf searches for el in the collection and returns the first index where
// el is found. If el is not present in the collection IndexOf will return -1.
func (c *ImmutableMapStringToReaderCollection) IndexOf(el map[string]io.Reader) int {
	for i, item := range c.items {
		if reflect.DeepEqual(item, el) {
			return i
		}
	}

	return -1
}

// First returns the first item from the collection. Will panic if the
// underlying slice is empty.
func (c *ImmutableMapStringToReaderCollection) First() map[string]io.Reader {
	return c.Nth(0)
}

// FirstN returns the first n map[string]io.Reader items of the collection. Will
// return less than n items if the underlying slice's length is < n.
func (c *ImmutableMapStringToReaderCollection) FirstN(n int) []map[string]io.Reader {
	if n > c.Len() {
		return c.Copy().Items()
	}

	return c.Slice(0, n)
}

// Last returns the last item from the collection. Will panic if the underlying
// slice is empty.
func (c *ImmutableMapStringToReaderCollection) Last() map[string]io.Reader {
	return c.Nth(c.Len() - 1)
}

// LastN returns the last n map[string]io.Reader items of the collection. Will return
// less than n items if the underlying slice's length is < n.
func (c *ImmutableMapStringToReaderCollection) LastN(n int) []map[string]io.Reader {
	if c.Len()-n < 0 {
		return c.Copy().Items()
	}

	return c.Slice(c.Len()-n, c.Len())
}

// Get returns the item at pos from the collection. Will panic if the
// underlying slice is shorter than pos+1.
func (c *ImmutableMapStringToReaderCollection) Get(pos int) map[string]io.Reader {
	return c.Nth(pos)
}

// Nth returns the nth item from the collection. Will panic if the underlying
// slice is shorter than pos+1.
func (c *ImmutableMapStringToReaderCollection) Nth(pos int) map[string]io.Reader {
	return c.items[pos]
}

// Len returns the length of the underlying map[string]io.Reader slice.
func (c *ImmutableMapStringToReaderCollection) Len() int {
	return len(c.items)
}

// Cap returns the capacity of the underlying map[string]io.Reader slice.
func (c *ImmutableMapStringToReaderCollection) Cap() int {
	return cap(c.items)
}

// Append appends items and returns the collection. The
// original collection will not be modified.
func (c *ImmutableMapStringToReaderCollection) Append(items ...map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	d.items = append(d.items, items...)
	return d
}

// Prepend prepends items and returns the collection. The
// original collection will not be modified.
func (c *ImmutableMapStringToReaderCollection) Prepend(items ...map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	d.items = append(items, d.items...)
	return d
}

// Copy creates a copy of the collection and the underlying map[string]io.Reader slice.
func (c *ImmutableMapStringToReaderCollection) Copy() *ImmutableMapStringToReaderCollection {
	s := make([]map[string]io.Reader, c.Len(), c.Len())
	copy(s, c.items)

	return NewImmutableMapStringToReaderCollection(s)
}

// Filter collects all items for which fn evaluates to true into a new
// collection. The original collection is not altered.
func (c *ImmutableMapStringToReaderCollection) Filter(fn func(map[string]io.Reader) bool) *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	s := d.items[:0]

	for _, item := range d.items {
		if fn(item) {
			s = append(s, item)
		}
	}

	var zeroValue map[string]io.Reader

	for i := len(s); i < len(d.items); i++ {
		d.items[i] = zeroValue
	}

	d.items = s

	return d
}

// Collect collects all items for which fn evaluates to true into a new
// collection. The original collection is not altered.
func (c *ImmutableMapStringToReaderCollection) Collect(fn func(map[string]io.Reader) bool) *ImmutableMapStringToReaderCollection {
	return c.Filter(fn)
}

// Reject collects all items for which fn evaluates to false into a new
// collection. The original collection is not altered.
func (c *ImmutableMapStringToReaderCollection) Reject(fn func(map[string]io.Reader) bool) *ImmutableMapStringToReaderCollection {
	return c.Filter(func(v map[string]io.Reader) bool {
		return !fn(v)
	})
}

// Partition partitions the collection into two new collections. The first
// collection contains all items where fn evaluates to true, the second one all
// items where fn evaluates to false.
func (c *ImmutableMapStringToReaderCollection) Partition(fn func(map[string]io.Reader) bool) (*ImmutableMapStringToReaderCollection, *ImmutableMapStringToReaderCollection) {
	lhs := make([]map[string]io.Reader, 0, c.Len())
	rhs := make([]map[string]io.Reader, 0, c.Len())

	for _, item := range c.items {
		if fn(item) {
			lhs = append(lhs, item)
		} else {
			rhs = append(rhs, item)
		}
	}

	return NewImmutableMapStringToReaderCollection(lhs), NewImmutableMapStringToReaderCollection(rhs)
}

// Map calls fn for each item in the collection an replaces its value with the
// result of fn. The result is a new collection. The original
// collection is not modified.
func (c *ImmutableMapStringToReaderCollection) Map(fn func(map[string]io.Reader) map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	return c.MapIndex(func(item map[string]io.Reader, _ int) map[string]io.Reader {
		return fn(item)
	})
}

// MapIndex calls fn for each item in the collection an replaces its value with the
// result of fn. The result is a new collection. The original
// collection is not modified.
func (c *ImmutableMapStringToReaderCollection) MapIndex(fn func(map[string]io.Reader, int) map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	d := c.Copy()

	for i, item := range d.items {
		d.items[i] = fn(item, i)

	}

	return d
}

// Reduce calls fn for each item in c and reduces the result into reducer. The
// reducer contains the value returned by the call to fn for the previous item.
// Reducer will be the zero map[string]io.Reader value on the first invocation.
func (c *ImmutableMapStringToReaderCollection) Reduce(fn func(reducer map[string]io.Reader, item map[string]io.Reader) map[string]io.Reader) map[string]io.Reader {
	var reducer map[string]io.Reader

	for _, item := range c.items {
		reducer = fn(reducer, item)
	}

	return reducer
}

// Find returns the first item for which fn evaluates to true. If the
// collection does not contain a matching item, Find will return the zero
// map[string]io.Reader value. If you need to distinguish zero values from a condition
// that did not match any item consider using FindOk instead.
func (c *ImmutableMapStringToReaderCollection) Find(fn func(map[string]io.Reader) bool) map[string]io.Reader {
	item, _ := c.FindOk(fn)

	return item
}

// FindOk returns the first item for which fn evaluates to true. If the
// collection does not contain a matching item, FindOk will return the zero
// map[string]io.Reader value. The second return value denotes whether the condition
// matched any item or not.
func (c *ImmutableMapStringToReaderCollection) FindOk(fn func(map[string]io.Reader) bool) (map[string]io.Reader, bool) {
	for _, item := range c.items {
		if fn(item) {
			return item, true
		}
	}

	var zeroValue map[string]io.Reader
	return zeroValue, false
}

// Any returns true as soon as fn evaluates to true for one item in c.
func (c *ImmutableMapStringToReaderCollection) Any(fn func(map[string]io.Reader) bool) bool {
	for _, item := range c.items {
		if fn(item) {
			return true
		}
	}

	return false
}

// All returns true if fn evaluates to true for all items in c.
func (c *ImmutableMapStringToReaderCollection) All(fn func(map[string]io.Reader) bool) bool {
	for _, item := range c.items {
		if !fn(item) {
			return false
		}
	}

	return true
}

// Contains returns true if the collection contains el.
func (c *ImmutableMapStringToReaderCollection) Contains(el map[string]io.Reader) bool {
	for _, item := range c.items {
		if reflect.DeepEqual(item, el) {
			return true
		}
	}

	return false
}

// Sort sorts the collection using the passed in comparator func.
// The result will be a copy of c which is sorted, the original collection is
// not altered.
func (c *ImmutableMapStringToReaderCollection) Sort(fn func(map[string]io.Reader, map[string]io.Reader) bool) *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	sort.Slice(d.items, d.lessFunc(fn))
	return d
}

// IsSorted returns true if the collection is sorted in the order defined by
// the passed in comparator func.
func (c *ImmutableMapStringToReaderCollection) IsSorted(fn func(map[string]io.Reader, map[string]io.Reader) bool) bool {
	return sort.SliceIsSorted(c.items, c.lessFunc(fn))
}

func (c *ImmutableMapStringToReaderCollection) lessFunc(fn func(map[string]io.Reader, map[string]io.Reader) bool) func(int, int) bool {
	return func(i, j int) bool {
		return fn(c.items[i], c.items[j])
	}
}

// Reverse copies the collection and returns it with the order of all items
// reversed.
func (c *ImmutableMapStringToReaderCollection) Reverse() *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	for l, r := 0, len(d.items)-1; l < r; l, r = l+1, r-1 {
		d.items[l], d.items[r] = d.items[r], d.items[l]
	}

	return d
}

// Remove removes the collection item at position pos. Will panic if pos is out
// of bounds.
// The result is a new collection, the original is not modified.
func (c *ImmutableMapStringToReaderCollection) Remove(pos int) *ImmutableMapStringToReaderCollection {
	d := c.Copy()
	d.items = append(d.items[:pos], d.items[pos+1:]...)
	return d
}

// RemoveItem removes all instances of item from the collection and returns it.
// The result is a new collection, the original is not modified.
func (c *ImmutableMapStringToReaderCollection) RemoveItem(item map[string]io.Reader) *ImmutableMapStringToReaderCollection {
	d := c.Copy()

	for i, el := range d.items {
		if reflect.DeepEqual(el, item) {
			d.items = append(d.items[:i], d.items[i+1:]...)
		}
	}

	return d
}

// InsertItem inserts item into the collection at position pos. Will panic if
// pos is out of bounds.
// The result is a new collection, the original is not modified.
func (c *ImmutableMapStringToReaderCollection) InsertItem(item map[string]io.Reader, pos int) *ImmutableMapStringToReaderCollection {
	var zeroValue map[string]io.Reader
	d := c.Copy()
	d.items = append(d.items, zeroValue)
	copy(d.items[pos+1:], d.items[pos:])
	d.items[pos] = item
	return d
}

// Cut returns a copy of the underlying map[string]io.Reader slice with the items
// between index i and j removed. Will panic if i or j is out of bounds of the
// underlying slice.
func (c *ImmutableMapStringToReaderCollection) Cut(i, j int) []map[string]io.Reader {
	d := c.Copy()
	return append(d.items[:i], d.items[j:]...)
}

// Slice returns the map[string]io.Reader items between slice index i and j. Will
// panic if i or j is out of bounds.
func (c *ImmutableMapStringToReaderCollection) Slice(i, j int) []map[string]io.Reader {
	return c.Copy().items[i:j]
}
