package generator

import (
	"go/build"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/martinohmann/collections-gen/internal/schema"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"k8s.io/gengo/args"
	"k8s.io/gengo/parser"
	"k8s.io/gengo/types"
)

type file struct {
	path     string
	contents string
}

type expectation struct {
	presentMethods []string
	absentMethods  []string
	elemType       *types.Type
}

func TestCodeGen(t *testing.T) {
	tests := []struct {
		name                string
		files               []file
		inputDirs           []string
		outputPackagePath   string
		expectedCollections map[string]expectation
		expectedMethods     map[string][]string
		expectedErr         error
	}{
		{
			name: "simple",
			files: []file{
				{
					path: "foo/type.go",
					contents: `
package foo

// +collections-gen=true
type Foo struct {}
`,
				},
			},
			outputPackagePath: "foo/bar",
			inputDirs:         []string{"foo"},
			expectedCollections: map[string]expectation{
				"FooCollection": {
					elemType: &types.Type{
						Kind: types.Struct,
						Name: types.Name{Package: "base/foo", Name: "Foo"},
					},
				},
			},
		},
		{
			name: "pointer",
			files: []file{
				{
					path: "foo/type.go",
					contents: `
package foo

// +collections-gen=true
// +collections-gen:options=pointer,name=BarCollection
type Foo struct {}
`,
				},
			},
			outputPackagePath: "foo/bar",
			inputDirs:         []string{"foo"},
			expectedCollections: map[string]expectation{
				"BarCollection": {
					elemType: &types.Type{
						Kind: types.Pointer,
						Name: types.Name{Name: "*base/foo.Foo"},
						Elem: &types.Type{
							Kind: types.Struct,
							Name: types.Name{Package: "base/foo", Name: "Foo"},
						},
					},
				},
			},
		},
		{
			name: "underlying",
			files: []file{
				{
					path: "foo/type.go",
					contents: `
package foo

// +collections-gen=true
// +collections-gen:options=underlying
type Foo map[string]string
`,
				},
			},
			outputPackagePath: "foo/bar",
			inputDirs:         []string{"foo"},
			expectedCollections: map[string]expectation{
				"FooCollection": {
					elemType: &types.Type{
						Kind: types.Map,
						Name: types.Name{Name: "map[string]string"},
						Elem: types.String,
					},
				},
			},
		},
		{
			name: "multiple collections",
			files: []file{
				{
					path: "foo/type.go",
					contents: `
package foo

// +collections-gen=true
type Foo struct {}
`,
				},
				{
					path: "foo/bar/type.go",
					contents: `
package bar

// +collections-gen=true
// +collections-gen:options=underlying,suffix=List
type Bar string
`,
				},
			},
			outputPackagePath: "foo/baz",
			inputDirs:         []string{"foo", "foo/bar"},
			expectedCollections: map[string]expectation{
				"FooCollection": {
					elemType: &types.Type{
						Kind: types.Struct,
						Name: types.Name{Package: "base/foo", Name: "Foo"},
					},
				},
				"BarList": {
					elemType: types.String,
				},
			},
		},
		{
			name: "multiple collections for one type",
			files: []file{
				{
					path: "foo/type.go",
					contents: `
package foo

// +collections-gen=true
// +collections-gen:options=name=BarCollection
// +collections-gen:options=immutable
type Foo struct {}
`,
				},
			},
			outputPackagePath: "foo/bar",
			inputDirs:         []string{"foo"},
			expectedCollections: map[string]expectation{
				"BarCollection": {
					elemType: &types.Type{
						Kind: types.Struct,
						Name: types.Name{Package: "base/foo", Name: "Foo"},
					},
				},
				"ImmutableFooCollection": {
					elemType: &types.Type{
						Kind: types.Struct,
						Name: types.Name{Package: "base/foo", Name: "Foo"},
					},
				},
			},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			pkgPrefix := "base"

			tempDir := newTempDir(t, pkgPrefix)

			defer tempDir.Cleanup()

			tempDir.AddFiles(test.files)

			inputDirs := make([]string, len(test.inputDirs))

			for i, dir := range test.inputDirs {
				inputDirs[i] = filepath.Join(pkgPrefix, dir)
			}

			// Setup fake GOROOT in tempDir
			build.Default.GOROOT = tempDir.name

			arguments := &args.GeneratorArgs{
				OutputBase:                 filepath.Join(tempDir.name, "src", pkgPrefix),
				GeneratedBuildTag:          "ignore_autogenerated",
				GeneratedByCommentTemplate: "// Code generated by GENERATOR_NAME. DO NOT EDIT.",
				InputDirs:                  inputDirs,
				OutputPackagePath:          test.outputPackagePath,
			}

			err := arguments.Execute(
				NameSystems(),
				DefaultNameSystem(),
				Packages,
			)
			if test.expectedErr != nil {
				require.Error(t, err)
				assert.Equal(t, test.expectedErr.Error(), err.Error())
			} else {
				require.NoError(t, err)

				universe := tempDir.FindTypes()

				for typeName, expectation := range test.expectedCollections {
					pkgPath := filepath.Join(pkgPrefix, test.outputPackagePath)

					pkg, ok := universe[pkgPath]
					if !ok {
						t.Fatalf("expected package %q not found", pkgPath)
					}

					typ, ok := pkg.Types[typeName]
					if !ok {
						t.Fatalf("expected type %q not found", typeName)
					}

					collectionName := types.Name{
						Package: pkgPath,
						Name:    typeName,
					}

					methodMap := make(map[string]bool)
					for _, method := range expectation.presentMethods {
						methodMap[method] = true
					}

					for _, method := range expectation.absentMethods {
						methodMap[method] = false
					}

					for methodName, expectPresent := range methodMap {
						_, present := typ.Methods[methodName]
						switch {
						case expectPresent && !present:
							t.Fatalf("expected type %q to have method %q but it was not found", typeName, methodName)
						case !expectPresent && present:
							t.Fatalf("expected type %q to not have method %q but it was found", typeName, methodName)
						}
					}

					collectionSchema := schema.Collection(collectionName, expectation.elemType)
					for methodName, expectedMethod := range collectionSchema.Methods {
						expectPresent := true

						if len(methodMap) > 0 {
							var ok bool
							expectPresent, ok = methodMap[methodName]
							if !ok {
								continue
							}
						}

						method, present := typ.Methods[methodName]
						switch {
						case expectPresent && !present:
							t.Fatalf("expected type %q to have method %q but it was not found", typeName, methodName)
						case !expectPresent && present:
							t.Fatalf("expected type %q to not have method %q but it was found", typeName, methodName)
						}

						err := schema.ValidateType(expectedMethod, method)
						if err != nil {
							t.Fatalf("invalid method %q on type %q: %v", methodName, typeName, err)
						}
					}
				}
			}
		})
	}
}

type tempDir struct {
	t         *testing.T
	pkgPrefix string
	name      string
}

func newTempDir(t *testing.T, pkgPrefix string) *tempDir {
	name, err := ioutil.TempDir("", "collections-gen")
	if err != nil {
		t.Fatal(err)
	}

	return &tempDir{
		t:         t,
		pkgPrefix: pkgPrefix,
		name:      name,
	}
}

func (d *tempDir) AddFiles(files []file) {
	for _, f := range files {
		d.AddFile(f)
	}
}

func (d *tempDir) AddFile(f file) {
	path := filepath.Join(d.name, "src", d.pkgPrefix, strings.TrimPrefix(f.path, "/"))

	dir := filepath.Dir(path)

	_, err := os.Stat(dir)
	if os.IsNotExist(err) {
		err = os.MkdirAll(dir, 0755)
	}

	if err != nil {
		d.t.Fatal(err)
	}

	err = ioutil.WriteFile(path, []byte(f.contents), 0644)
	if err != nil {
		d.t.Fatal(err)
	}
}

func (d *tempDir) Cleanup() {
	os.RemoveAll(d.name)
}

func (d *tempDir) FindTypes() types.Universe {
	b := parser.New()
	err := b.AddDirRecursive(d.pkgPrefix)
	if err != nil {
		d.t.Fatal(err)
	}

	u, err := b.FindTypes()
	if err != nil {
		d.t.Fatal(err)
	}

	return u
}
